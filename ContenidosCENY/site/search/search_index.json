{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computaci\u00f3n en la Nube y Virtualizaci\u00f3n","text":"<p>\u00cdNDICE DE CONTENIDOS:</p> <ol> <li>Elementos clave de una Infraestructura de Red</li> <li>Cloud Computing</li> <li>Virtualizaci\u00f3n</li> <li>Introducci\u00f3n a Docker</li> </ol> <p>Materiales Optativa Computaci\u00f3n en la Nube by Lorenzo Le\u00f3n Valor is licensed under CC BY-NC-SA 4.0</p>"},{"location":"unidad1/ud1/","title":"UNIDAD 1: ELEMENTOS CLAVE DE UNA INFRAESTRUCTURA DE RED","text":""},{"location":"unidad1/ud1/#el-protocolo-ip","title":"EL PROTOCOLO IP","text":""},{"location":"unidad1/ud1/#que-es","title":"\u00bfQUE ES?","text":"<ul> <li> <p>El protocolo IP (Internet Protocol) es uno de los m\u00e1s utilizados y m\u00e1s importantes de los que operan en la capa 3 del modelo OSI. Ya que permite la comunicaci\u00f3n entre dispositivos conectados a redes distintas. Para ello, se le asigna una numeraci\u00f3n a cada equipo, que lo identifica de forma \u00faniva dentro de la misma red, conocida como direcci\u00f3n IP.</p> </li> <li> <p>Una direcci\u00f3n IP consiste en un numero binario de 32 bits, divido en grupos de 4 octetos (8 bits; lo que implica que cada octeto podr\u00e1 tomar valores de 0 hasta 255 como m\u00e1ximo), separados por puntos. La forma m\u00e1s com\u00fan de representarla es en formato decimal, como por ejemplo 192.168.200.255</p> </li> </ul>"},{"location":"unidad1/ud1/#clases-de-direcciones-ip","title":"CLASES DE DIRECCIONES IP","text":"<ul> <li>Seg\u00fan su numeraci\u00f3n, distinguiremos 5 clases diferentes de direcciones IP: </li> </ul>"},{"location":"unidad1/ud1/#direccionamiento-privado","title":"DIRECCIONAMIENTO PRIVADO","text":"<ul> <li>No obstante, dentro de cada clase existen rangos privados de direccionamiento. Estos rangos son los que usaremos cuando estemos configurando los dispositivos englobados en una misma red LAN y cuyas direcciones no deban ser visibles desde internet. Son los siguientes:</li> </ul>"},{"location":"unidad1/ud1/#direccionamiento-reservado","title":"DIRECCIONAMIENTO RESERVADO","text":"<ul> <li> <p>Adem\u00e1s, tambi\u00e9n existen ciertos rangos de direcciones reservadas, que no deben usarse excepto para el uso que tienen asignados, como pueden ser el 127.0.0.0/8 que se utiliza para direcciones de Loopback, o el 0.0.0.0/0 que se utiliza como Ruta por Defecto.</p> </li> <li> <p>Al resto de direccionamiento que no se incluye en los rangos privados y reservados, lo llamaremos direcciones p\u00fablicas, que son las que se usan en Internet.</p> </li> </ul>"},{"location":"unidad1/ud1/#estructura-de-una-direccion-ip","title":"ESTRUCTURA DE UNA DIRECCI\u00d3N IP","text":"<ul> <li>En una direcci\u00f3n IP vamos a diferenciar 2 partes, la izquierda o identificador de red, y la derecha o identificador de host. Como se ha visto en la tabla anterior, dependiendo de la clase a la que pertenezca una direcci\u00f3n IP, su red tendr\u00e1 un tama\u00f1o por defecto para cada una de esas partes, que ser\u00eda el siguiente:</li> </ul>"},{"location":"unidad1/ud1/#la-mascara-de-red","title":"LA M\u00c1SCARA DE RED","text":"<ul> <li>Para indicarnos la cantidad de bits pertenece a cada una de estas partes, tenemos la m\u00e1scara de red. Se trata de un indicador n\u00famerico con el mismo tama\u00f1o y distribuci\u00f3n de bits que una direcci\u00f3n IP, y que suele indicarse a continuaci\u00f3n de esta.</li> <li>Podemos expresarla tanto en formato decimal (similar a una IP) o en formato abreviado o CIDR (Classles Inter-Domain Routing), con un /N, siendo N el n\u00famero de bits usados para el identificador de red. Lo vemos en el siguiente ejemplo:</li> </ul>"},{"location":"unidad1/ud1/#los-puertos-logicos","title":"LOS PUERTOS L\u00d3GICOS","text":""},{"location":"unidad1/ud1/#que-son","title":"\u00bfQUE SON?","text":"<ul> <li>Son como interfaces virtuales que permiten la comunicaci\u00f3n entre diferentes aplicaciones o servicios en una misma computadora o entre distintas computadoras a trav\u00e9s de la red. Son identificadores n\u00famericos de 16 bits, a trav\u00e9s de los cuales podemos conocer que servicio o protocolo se est\u00e1 usando.</li> </ul>"},{"location":"unidad1/ud1/#tipos-de-puertos-logicos","title":"TIPOS DE PUERTOS L\u00d3GICOS","text":"<ul> <li>Tanto en TCP como en UDP tenemos un total de 65535 puertos disponibles, tenemos una clasificaci\u00f3n dependiendo del n\u00famero de puerto a utilizar, que es la siguiente:<ul> <li>Puertos conocidos: los puertos conocidos (well-known en ingl\u00e9s) van desde el puerto 0 hasta al 1023, est\u00e1n registrados y asignados por la Autoridad de N\u00fameros Asignados de Internet (IANA), a los servicios y protocolos de red m\u00e1s comunes.</li> <li>Puertos registrados: los puertos registrados van desde el puerto 1024 hasta al 49151. La principal diferencia de estos puertos, es que las diferentes organizaciones pueden hacer solicitudes a la IANA para que se le otorgue un determinado puerto por defecto, y se le asignar\u00e1 para su uso con una aplicaci\u00f3n en concreto.</li> <li>Puertos din\u00e1micos: estos puertos van desde el 49152 hasta el 65535, este rango de puertos se utiliza por los programas del cliente y est\u00e1n constantemente reutiliz\u00e1ndose. Este rango de puertos normalmente se utiliza cuando est\u00e1 transmitiendo a un puerto conocido o reservado desde otro dispositivo, como en el caso de web o FTP. Por ejemplo, cuando nosotros visitamos una web, el puerto de destino siempre ser\u00e1 el 80 (HTTP) o el 443 (HTTPS), pero como puerto origen se usar\u00e1 uno din\u00e1mico.</li> </ul> </li> </ul>"},{"location":"unidad1/ud1/#puertos-mas-usados","title":"PUERTOS M\u00c1S USADOS","text":""},{"location":"unidad1/ud1/#principales-protocolos-de-red","title":"PRINCIPALES PROTOCOLOS DE RED","text":""},{"location":"unidad1/ud1/#arp","title":"ARP","text":"<ul> <li>\uf071Es un protocolo de capa 2. Se encarga de asociar la direcci\u00f3n MAC de cada maquina, a su direcci\u00f3n IP. ADDRESS RESOLUTION PROTOCOL</li> </ul> <p>PROTOCOLO DE RESOLUCI\u00d3N DE DIRECCIONES - Cuando un equipo intenta comunicarse por primera vez con otra maquina de su red, se enviar\u00e1 previamente una \"petici\u00f3n ARP\", en forma de mensaje de broadcast a todos los equipos de la red. - De modo que solo responder\u00e1 el equipo que tenga la MAC con la que queramos comunicarnos. - As\u00ed, cada equipo de la red ir\u00e1 generando lo que llamamos su \"Tabla ARP\", en la que iran quedando registradas las direcciones MAC de cada m\u00e1quina, asociada con su direcci\u00f3n IP correspondiente.</p>"},{"location":"unidad1/ud1/#icmp","title":"ICMP","text":"<p>Es un protocolo de capa 3. Nos sirve para comprobar si tenemos conectividad con otro dispositivos de nuestra red o de otra distinta. Esto lo hace generando paquetes IP de un tama\u00f1o concreto y envi\u00e1ndolos a otra m\u00e1quina de la red para ver si responde. - Herramientas como ping y traceroute utilizan ICMP para probar la disponibilidad de un destino, medir tiempos de respuesta o mostrar la ruta que siguen los paquetes.</p>"},{"location":"unidad1/ud1/#dns","title":"DNS","text":"<ul> <li>Se considera un servicio de capa 7. Es un servicio o funcionalidad, que nos permite acceder o comunicarnos con otros equipos o recursos de una red, utilizando su nombre de dominio e incluso un alias.</li> <li>Evitando as\u00ed tener que recordar la direcci\u00f3n IP de cada maquina, que ser\u00eda mucho m\u00e1s complejo.</li> <li>Para ello, tendremos configurado en nuestra red uno o m\u00e1s servidores DNS, a los cuales les enviaremos peticiones cada vez que nos comunicamos con otro equipo a trav\u00e9s de su nombre de dominio; y estos realizaran la traducci\u00f3n de ese nombre o alias, a la direcci\u00f3n IP que le corresponde.</li> <li>Este servicio funciona de manera totalmente transparente para el usuario.</li> </ul>"},{"location":"unidad1/ud1/#nat","title":"NAT","text":"<ul> <li>Mecanismo mediante el cual podemos traducir una o varias direcciones IP privadas (locales), en una o varios IP p\u00fablicas (globales) y viceversa. De esta forma, los equipos de una red local pueden acceder a internet sin que sus direcciones IP privadas sean visibles fuera de su red local.</li> <li> <p>A parte de esta, la principal funci\u00f3n de NAT es la de conservar el espacio global IPv4 y evitar su agotamiento. Ya qu\u00e9 gracias a \u00e9l, podemos conseguir que utilizando una sola IP p\u00fablica, salgan internet todos los equipos de una red local. Distinguimos 3 tipos de NAT:</p> <ul> <li>NAT Est\u00e1tico: asigna de forma manual una direcci\u00f3n IP p\u00fablica a una direcci\u00f3n privada. Mapeo \u201cuno a uno\u201d permanente.</li> <li>NAT Din\u00e1mico: consiste en asignar un grupo de direcciones p\u00fablicas a una red local, de modo que los dispositivos podr\u00e1n ir utilizando din\u00e1micamente esas direcciones p\u00fablicas para salir a internet y dejarlas libres cuando terminen. Mapeo \u201cuno a uno\u201d temporal.</li> <li>NAT con Sobrecarga: tambi\u00e9n conocido como PAT (Port Address Translation), permite asignar una IP p\u00fablica a toda una red y que los dispositivos la utilicen de forma simultanea para salir a internet. Realiz\u00e1ndose la diferenciaci\u00f3n entre equipos por puertos. Mapeo \u201cuno a varios\u201d.</li> </ul> </li> <li> <p> Aclaraci\u00f3n:     <pre><code>- Direcci\u00f3n local interna: la direcci\u00f3n de origen vista desde el interior de la red.\n- Direcci\u00f3n global interna: la direcci\u00f3n de origen vista desde la red externa.\n- Direcci\u00f3n global externa: la direcci\u00f3n del destino vista desde la red externa.\n- Direcci\u00f3n local externa: la direcci\u00f3n del destino vista desde la red interna.\n</code></pre></p> </li> </ul>"},{"location":"unidad1/ud1/#dhcp","title":"DHCP","text":"<ul> <li>Es un protocolo de capa 7. Nos permite configurar varios par\u00e1metros de conectividad (direcci\u00f3n IP, M\u00e1scara, Puerta de Enlace, Servidores DNS...) de manera autom\u00e1tica, en las diferentes m\u00e1quinas conectadas a una red.</li> <li>Para ello, debemos configurar previamente uno de los equipos de red, para que ejecute dicho servicio, es decir, har\u00e1 la funci\u00f3n de servidor. De modo que cada vez que un equipo se conecte a dicha red, solamente tengamos que activar en \u00e9l, la funcionalidad DHCP (Cliente, que generalmente viene habilitada por defecto) y realizar\u00e1 la petici\u00f3n de forma autom\u00e1tica, obteniendo as\u00ed su configuraci\u00f3n de red, sin necesidad de hacerlo manualmente equipo por equipo.</li> </ul>"},{"location":"unidad2/ud2/","title":"UNIDAD 2: CLOUD COMPUTING","text":""},{"location":"unidad2/ud2/#que-es-la-computacion-en-la-nube","title":"\u00bfQUE ES LA COMPUTACI\u00d3N EN LA NUBE?","text":""},{"location":"unidad2/ud2/#concepto","title":"Concepto","text":""},{"location":"unidad2/ud2/#breve-historia","title":"Breve Historia","text":""},{"location":"unidad2/ud2/#caracteristicas-de-los-serivicios-en-la-nube","title":"CARACTER\u00cdSTICAS DE LOS SERIVICIOS EN LA NUBE","text":""},{"location":"unidad2/ud2/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"unidad2/ud2/#estructura-general-arquitectura-en-la-nube","title":"Estructura general arquitectura en la nube","text":""},{"location":"unidad2/ud2/#frontend","title":"FrontEnd","text":""},{"location":"unidad2/ud2/#backend","title":"BackEnd","text":""},{"location":"unidad2/ud2/#middleware","title":"Middleware","text":""},{"location":"unidad2/ud2/#opciones-de-contratacion","title":"Opciones de contrataci\u00f3n","text":""},{"location":"unidad2/ud2/#saas","title":"SaaS","text":""},{"location":"unidad2/ud2/#paas","title":"PaaS","text":""},{"location":"unidad2/ud2/#iaas","title":"IaaS","text":""},{"location":"unidad2/ud2/#seguridad-en-la-nube-amenazas","title":"Seguridad en la nube: Amenazas","text":""},{"location":"unidad2/ud2/#seguridad-en-la-nube-riesgos","title":"Seguridad en la nube: Riesgos","text":""},{"location":"unidad2/ud2/#modelos-de-implementacion-en-la-nube","title":"MODELOS DE IMPLEMENTACI\u00d3N EN LA NUBE","text":""},{"location":"unidad2/ud2/#nube-publica","title":"Nube P\u00fablica","text":""},{"location":"unidad2/ud2/#nube-privada","title":"Nube Privada","text":""},{"location":"unidad2/ud2/#nube-hibrida","title":"Nube H\u00edbrida","text":""},{"location":"unidad2/ud2/#multinube","title":"Multinube","text":""},{"location":"unidad2/ud2/#ventajas-y-desventajas-de-cada-modelo","title":"VENTAJAS Y DESVENTAJAS DE CADA MODELO","text":""},{"location":"unidad2/ud2/#nube-publica_1","title":"Nube P\u00fablica","text":""},{"location":"unidad2/ud2/#nube-privada_1","title":"Nube Privada","text":""},{"location":"unidad2/ud2/#nube-hibrida_1","title":"Nube H\u00edbrida","text":""},{"location":"unidad2/ud2/#multinube_1","title":"Multinube","text":""},{"location":"unidad2/ud2/#principales-proveedores-y-servicios","title":"PRINCIPALES PROVEEDORES Y SERVICIOS","text":""},{"location":"unidad2/ud2/#cuota-de-mercado-por-proveedor","title":"Cuota de Mercado por Proveedor","text":""},{"location":"unidad2/ud2/#amazon-web-services-aws","title":"Amazon Web Services (AWS)","text":""},{"location":"unidad2/ud2/#microsoft-azure","title":"Microsoft Azure","text":""},{"location":"unidad2/ud2/#google-cloud","title":"Google Cloud","text":""},{"location":"unidad2/ud2/#oracle-cloud","title":"Oracle Cloud","text":""},{"location":"unidad2/ud2/#clouding","title":"Clouding","text":""},{"location":"unidad2/ud2/#equivalencia-entre-servicios","title":"Equivalencia entre servicios","text":""},{"location":"unidad3/ud3/","title":"UNIDAD 3: VIRTUALIZACI\u00d3N","text":""},{"location":"unidad3/ud3/#que-es-la-virtualizacion","title":"\u00bfQUE ES LA VIRTUALIZACI\u00d3N?","text":""},{"location":"unidad3/ud3/#tipos-de-virtualizacion","title":"TIPOS DE VIRTUALIZACI\u00d3N","text":""},{"location":"unidad3/ud3/#metodos-de-implementacion","title":"M\u00c9TODOS DE IMPLEMENTACI\u00d3N","text":""},{"location":"unidad3/ud3/#categorias-de-virtualizacion","title":"CATEGOR\u00cdAS DE VIRTUALIZACI\u00d3N","text":""},{"location":"unidad3/ud3/#beneficios-de-la-virtualizacion","title":"BENEFICIOS DE LA VIRTUALIZACI\u00d3N","text":""},{"location":"unidad3/ud3/#limitaciones","title":"LIMITACIONES","text":""},{"location":"unidad3/ud3/#tecnologias-especificas-de-virtualizacion","title":"TECNOLOG\u00cdAS ESPEC\u00cdFICAS DE VIRTUALIZACI\u00d3N","text":""},{"location":"unidad4/ud4/","title":"UNIDAD 4: INTRODUCCI\u00d3N A DOCKER","text":""},{"location":"unidad4/ud4/#concepto-y-caractaristicas","title":"CONCEPTO Y CARACTAR\u00cdSTICAS","text":""},{"location":"unidad4/ud4/#que-es-docker","title":"\u00bfQUE ES DOCKER?","text":"<ul> <li>Tecnolog\u00eda de virtualizaci\u00f3n ligera de software libre, tambi\u00e9n conocida como virtualizaci\u00f3n por contenedores.</li> <li>Son entornos de ejecuci\u00f3n aislados, con su propio sistema de ficheros, su propia configuraci\u00f3n de red y que acceden directamente a los recursos del anfitri\u00f3n (memoria, procesador...)</li> <li>No tienen kernel propio, utilizan el del anfitri\u00f3n.</li> <li>Su uso principal es para el despliegue de aplicaciones.</li> </ul>"},{"location":"unidad4/ud4/#elementos-basicos-de-docker","title":"ELEMENTOS B\u00c1SICOS DE DOCKER","text":"<ul> <li>IMAGEN: aplicaci\u00f3n empaquetada, es el sistema de ficheros de nuestro contenedor</li> <li>CONTENEDOR: una imagen en ejecuci\u00f3n</li> <li>Los contendores pueden conectarse a diferentes REDES VIRTUALES y tienen sus propios VOL\u00daMENES o sistemas de almacenamiento.</li> </ul>"},{"location":"unidad4/ud4/#arquitectura-de-docker","title":"ARQUITECTURA DE DOCKER","text":"<ul> <li>DEMONIO: es el m\u00e1s importante (Docker Engine) estar\u00e1 siempre en ejecuci\u00f3n y es el que gestiona los contenedores</li> <li>CLIENTE: linea de comandos que nos permite decirle al demonio que queremos hacer</li> <li>REGISTRO: repositorio de im\u00e1genes local (existe tambien uno p\u00fablico, Docker Hub, de donde podemos descargar)</li> <li> <p>DOCKER SWARN: software orquestador de contenedores. Sirve para gestionar conjuntos de contenedores en un cluster de servidores.   </p> </li> <li> <p>Alternativas a Docker: Podman (RedHat), Containerd (proyecto independiente basado en Docker), CRI-0 (RedHat, pensada para trabajar con Kubernetes), Pouch (AliBaba).</p> </li> <li>Los orquestadores de contenedores, se usan para automatizar y facilitar muchas de las tareas que se llevan a cabo con contenedores, sobretodo cuando hay que gestionar grandes cantidades de estos. Ejemplos son: Kubernetes, Apache Mesos o Docker Swarn.</li> </ul>"},{"location":"unidad4/ud4/#instalacion-de-docker","title":"INSTALACI\u00d3N DE DOCKER","text":"<ul> <li>Documentaci\u00f3n oficial</li> <li>Requerimientos m\u00ednimos Ubuntu</li> <li> <p>Docker solo corre sobre distribuciones Linux, para Windows y MAC, se puede usar instalando el software Docker Desktop, que en realidad crea una m\u00e1quina virtual Linux para ejecutar el demonio Docker sobre ella. Sin embargo el cliente si corre sobre el SO anfitri\u00f3n.</p> </li> <li> <p>Existen varios m\u00e9todos de instalaci\u00f3n, en nuestro caso usaremos los repositorios apt de de Docker:</p> <ol> <li> <p>Actualizamos los repositorios e instalamos los paquetes necesarios para instalar desde repositorios HTTPS:</p> <pre><code>sudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\n</code></pre> </li> <li> <p>A\u00f1adir la clave GPG oficial de Docker:</p> <pre><code>sudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n</code></pre> </li> <li> <p>A\u00f1adimos el repositorio oficial de Docker:</p> <pre><code>echo \\\n\"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n\"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\\nsudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n</code></pre> </li> <li> <p>Instalamos Docker Engine:</p> <pre><code>sudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> </li> </ol> </li> <li> <p>Para manejar Docker con un usuario sin privilegio, debemos a\u00f1adir el usuario al grupo <code>docker</code>, para ello:</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> </li> <li> <p>Debes volver a iniciar una terminal con el usuario, o ejecutar el siguiente comando:</p> <pre><code>su - $USER\n</code></pre> </li> <li> <p>Y finalmente, comprobamos la versi\u00f3n con la que vamos a trabajar:</p> <pre><code>docker --version\n</code></pre> </li> <li> <p>Si queremos m\u00e1s informaci\u00f3n de las versiones de los componentes con los que vamos a trabajar, ejecutamos:</p> <pre><code>docker version\n</code></pre> </li> <li> <p>Para m\u00e1s informaci\u00f3n del sistema que hemos instalado podemos ejecutar:</p> <pre><code>docker info\n</code></pre> </li> </ul>"},{"location":"unidad4/ud4/#ejecucion-de-contenedores","title":"EJECUCI\u00d3N DE CONTENEDORES","text":"<ul> <li>HOLA MUNDO:</li> <li> <p>Todos los subcomandos referidos a contenedores, estan dentro del bloque \"docker container\", pero por abreviaci\u00f3n, se omite \"container\" y solo se escribe \"docker\". Por ejemplo: docker container run = docker run</p> </li> <li> <p>Para ver todos los subcomandos con referidos a contenedores, podemos ejecutar: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4container\n</code></pre></p> </li> <li> <p>Como m\u00ednimo, para crear un contenedor debemos indicarle una imagen. Esa imagen debe estar en nuestro REGISTRO (repositorio) local, si no es as\u00ed, la buscara en el REGISTRO p\u00fablico (Docker Hub) y la descargar\u00e1. Por ejemplo, existe la imagen p\u00fablica \"hello-world\" que ejecuta un programa Hello World en el contenedor.</p> </li> <li> <p>Si no especificamos un nombre de contenedor al crearlo, la herramienta le asigna un nombre aleatorio.</p> </li> <li> <p>Todas las im\u00e1genes tienen definido un comando por defecto que ejecutar\u00e1n al crear un contendor con ellas. Por ejemplo, en el caso de las imagenes de sistemas operativos, como ubuntu, por defecto ejecutan el comando  <code>bash</code>.</p> </li> <li> <p>COMANDOS DE GESTI\u00d3N B\u00c1SICA:</p> </li> <li>Crear y ejecutar un contenedor: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4run hello-world\n</code></pre></li> <li>Crear un contenedor sin ejecutarlo: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4create hello-world\n</code></pre></li> <li>Iniciar un contenedor ya creado: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4start -a micontendor1\n# La opci\u00f3n -a sirve para ver la salida que genera la ejecuci\u00f3n de ese contenedor, en este caso el mensaje \"Hello form Docker!\"\n</code></pre></li> <li>Pausar la ejecuci\u00f3n de un contenedor: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4pause micontenedor\n</code></pre></li> <li>Finalizar la ejecuci\u00f3n de un contenedor: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4stop micontenedor\n</code></pre></li> <li>Reiniciar la ejecuci\u00f3n de un contenedor: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4restart micontenedor\n</code></pre></li> <li>Renombrar un contenedor ya creado: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4rename micontenedor nuevo_nombre\n</code></pre></li> <li>Borrar un contenedor: <pre><code>    #Medocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4diante su ID:\n    docker rm 64f44087771a\n    # Mediante su nombre\n    docker rm micontenedor1\n\n    # Para forzar el borrado de un contenedor en ejecuci\u00f3n, se usar\u00eda la opci\u00f3n -f\n    docker rm -f micontenedor1\n</code></pre></li> <li>Enlazar con la entrada/salida de un contenedor interactivo en ejecuci\u00f3n: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4attach micontenedor\n</code></pre></li> <li>Mostrar contenedores en ejecuci\u00f3n: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4ps\n</code></pre></li> <li>Mostrar contenedores creados: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4ps -a\n</code></pre></li> <li>Mostrar im\u00e1genes de nuestro REGISTRO local: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4images\n</code></pre></li> <li>Descargar una imagen del REGISTRO p\u00fablico: <pre><code>#Por ejdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4emplo, descargar la imagen del SO Ubuntu\ndocker pull ubuntu\n</code></pre></li> <li> <p>Visualizar los pasos que se dan cuando creamos o ejecutamos contenedores: <pre><code>#Dejamodocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4s lanzado este comando y se nos mostrar\u00e1n logs detallados de todos las acciones que ejecutemos despues:\ndocker events\n</code></pre></p> </li> <li> <p>OPCIONES COMUNES SOBRE LOS COMANDOS B\u00c1SICOS:</p> </li> <li>Indicar nombre del contenedor al crearlo: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4run --name contenedor1 ubuntu\n</code></pre></li> <li> <p>Para especificar que comando o comandos queremos que ejecute nuestro contenedor, se indican despues de la imagen: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4run --name contenedor1 ubuntu echo \"Hola Mundo\"\n</code></pre></p> </li> <li> <p>Indicar hostname del contenedor al crearlo: <pre><code>#Aunquedocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4 no es muy com\u00fan utilizarlo, ya que los contenedores ofrecen un servicio y por lo general no nos conectamos a ellos. Es decir, no suelen tratarse como m\u00e1quinas virtuales tradicionales a las que solemos conectarnos para realizar distintas tareas\ndocker -h contenedor_ubuntu\n</code></pre></p> </li> <li> <p>Crear una sesi\u00f3n de terminal interactivo al crear un contendor: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4run -it --name contenedor2 -h cont2 ubuntu bash\n</code></pre></p> </li> <li> <p>Borrar el contenedor despues de que termine su ejecuci\u00f3n: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4run -it --rm --name contenedor3 -h cont3 ubuntu top\n</code></pre></p> </li> <li> <p>CONTENEDORES DEMONIO: ejecutan procesos indefinidamente y de forma desatendida (no veremos su salida). Ejemplo: <pre><code># La opdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4ci\u00f3n -d indica que la ejecuci\u00f3n es desatendida, es decir, no veremos su salida. Y la opci\u00f3n -c, permite especificar entre comillas, un listado de comandos para ejecutar:\ndocker run -d --name micontenedor ubuntu bash -c \"while true; do echo hello world; sleep 1; done\"\n\n# Para ver la salida generada por un contenedor demonio\ndocker logs micontenedor\n\n#Y si queremos verlo de forma continuada, podemos especificar\ndocker logs -f micontenedor\n\n# Para detener un contenedor demonio\ndocker stop micontenedor\n\n# Una vez detenido, podemos eliminarlo si queremos\ndocker rm micontenedor\n</code></pre></p> </li> <li>CREACI\u00d3N DE VARIABLES DE ENTORNO ASOCIADAS A UN CONTENEDOR: Las variables de entorno son del tipo \"clave:valor\", y podemos crearlas al arrancar un contenedor. En el siguiente ejemplo, creamos la variable \"USUARIO\" y le asignamos el valor \"prueba\": <pre><code>#Crea udocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4n contenedor interactivo (-it) con la imagen de ubuntu y define una variable de entorno (-e) para ese contenedor:\ndocker run -it --name micontenedor -e USUARIO=prueba ubuntu\n</code></pre></li> <li>Para comprobar que realmente se ha creado la variable, dentro del BASH del contenedor escribimos <code>env</code> y veremos todas las variables d entorno.</li> <li> <p>Las variables de entorno, suele utilizarse mucho para definir ciertos par\u00e1metros de configuraci\u00f3n de las aplicaciones que se desplegamos mediante contenedores.</p> </li> <li> <p>COMANDOS DE GESTI\u00d3N M\u00c1S AVANZADOS: Ejecutar un comando dentro de un contenedor en ejecuci\u00f3n: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4 exec micontenedor ls\n#o\ndocker exec micontenedor cat datos.txt\n</code></pre> El comando anterior es muy utilizado para levantar sesiones interactivas de consola en contenedores ya creados, por ejemplo: <pre><code># Abrir una sesi\u00f3n interactiva en un contenedor MariaDB existente, ejecutando bash y pas\u00e1ndole usuario y contrase\u00f1a para autenticarse\ndocker exec -it some-mariadb bash -c 'mysql -u root -p$MARIADB_ROOT_PASSWORD'\n</code></pre></p> </li> </ul> <p>Copiar ficheros del Host al Contenedor o viceversa: <pre><code>#Para cdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4opar del host al contenedor, se especifica el nombre del contenedor y el directorio donde lo queremos copiar\ndocker cp mifichero.txt micontenedor:/\n\n#Para copiar del contenedor al host, debemos especificar el directorio destino, en este caso \".\" para indicar el directorio actual\ndocker cp micontenedor:/hora.txt .\n</code></pre></p> <p>Visualizar los procesos que se estan ejecutando dentro de un contenedor: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4top micontenedor\n</code></pre></p> <p>Obtener informaci\u00f3n detallada de un contenedor: <pre><code># Muestdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4ra en formato JSON el identificador, puertos abiertos, almacenamiento, tama\u00f1o, configuraci\u00f3n de red, comandos, varibles de entorno... \ndocker inspect micontenedor\n</code></pre></p> <p>Podemos formatear la salida del comando anterior, para que solo muestre ciertos par\u00e1metros: <pre><code># Para docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4mostrar el ID del contenedor\ndocker inspect --format='{{.Id}}' micontenedor\n\n#Para mostrar todas las variables de entorno:\ndocker inspect --format='{{range .Config.Env}}{{println .}}{{end}}' micontenedor\n\n#Para mostrar la direcci\u00f3n o direcciones IPs que tiene el contenedor:\ndocker inspect --format='{{range .NetworkSettings.Networks}}{{IPAddress}}{{end}}' micontenedor\n</code></pre></p> <p>Etiquetar contenedores, para filtrarlos o agruparlos <pre><code># USO ETIQUETADO\n</code></pre></p> <p>Limitar recursos utilizados por contenedores: <pre><code># La cantidad de CPU --cpus\n\n# La cantidad de memoria --memory\n</code></pre></p> <p>Visualizar estad\u00edsticas de uso de recursos de un contenedor <pre><code># ESTADISTICAS\n</code></pre></p> <p>Modificar en tiempo real las limitaciones de recursos de un contenedor en ejecuci\u00f3n <pre><code># MODIFICACI\u00d3N LIMITACIONES\n</code></pre></p>"},{"location":"unidad4/ud4/#desplegar-un-servidor-web-apache-con-docker","title":"DESPLEGAR UN SERVIDOR WEB APACHE CON DOCKER","text":"<p>Generalmente, nunca se va a utilizar la direcci\u00f3n IP del contenedor para acceder a los servicios que despliega, ya que esta es din\u00e1mica y puede ir cambiando dependiendo de que acciones realicemos en el contenedor.</p> <p>Adem\u00e1s, la direcci\u00f3n IP de un contenedor solamente es accesible desde el anfitri\u00f3n. No ser\u00eda alcanzable desde otros equipos de la red.</p> <p>Por lo tanto, en este caso para acceder al servidor Web que nos proporcionar\u00e1 este contenedor, vamos a <code>mapear puertos</code>. Es decir, con la opci\u00f3n <code>-p</code> indicamos que cuando accedamos al puerto 8080 del host, esa petici\u00f3n se reenv\u00ede al puerto 80 del contenedor, independientemente de la direcci\u00f3n IP.</p> <p>Ser\u00eda como si definieramos una regla de NAT en el Firewall del anfitri\u00f3n.</p> <pre><code># httpddocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4:2.4 es la imagen oficial del Servidor Web APACHE\ndocker run -d --name my-apache-app -p 8080:80 httpd:2.4\n</code></pre> <p>Para ver las redirecciones o nateos que se est\u00e1n haciendo en nuestro contenedor: <pre><code># Muestdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4ra tanto IPv4 como IPv6\ndocker port my-apache-app\n</code></pre></p> <p>Para conectarnos al servidor web bastar\u00e1 con ir al navegador del host y acceder a <code>https://localhost:8080</code></p>"},{"location":"unidad4/ud4/#desplegar-un-servidor-de-bbdd-con-docker","title":"DESPLEGAR UN SERVIDOR DE BBDD CON DOCKER","text":""},{"location":"unidad4/ud4/#introduccion-a-las-imagenes-en-docker","title":"INTRODUCCI\u00d3N A LAS IMAGENES EN DOCKER","text":"<p>Son plantillas de solo lectura que define el sistema de ficheros que va a tener el contenedor. Tambi\u00e9n establece el comando por defecto que ejecutar\u00e1 ese contenedor, siempre que no se indique otro.</p> <p>Por defecto en docker se usa el registro p\u00fablico de Docker Hub para descargar im\u00e1genes a nuestro registro local.</p> <p>La nomenclatura para identificar una imagen es <code>usuario/nombre:etiqueta</code>. Las im\u00e1genes oficiales de docker vienen sin nombre de usuario para diferenciarlas.</p> <p>Si no idicamos etiqueta al usar una imagen, por defecto se utiliza la etiqueta \"latest\" que se refiere a la \u00faltima versi\u00f3n disponible de esa imagen.</p> <p>Adem\u00e1s de la version, las etiquetas pueden indicar la tecnolog\u00eda interna que se usa para servir esa aplicaci\u00f3n y el SO base que usa esa imagen.</p> <ul> <li>\u00bfComo se organizan las im\u00e1genes? El sistema de ficheros (FS) de una im\u00e1gen se llama sistema de ficheros de uni\u00f3n, ya que es el resultado de la uni\u00f3n de varias capas.</li> </ul> <p>Cada capa representa una serie de directorios, que al juntarlos todos obtenemos nuestro FS final.</p> <p>Las imagenes suelen partir de una capa base, que contiene los directorios y archivos b\u00e1sicos para su funcionamiento. Y luego cada una de las otras capas define un conjunto de diferencias respecto a la capa anterior (ficheros a\u00f1adidos, modificados o eliminados).</p> <p>Si tengo varias im\u00e1genes que tengan la misma capa base, solo se almacenar\u00e1 una vez en nuestra m\u00e1quina y ser\u00e1 compartida por todas esas im\u00e1genes. Esto podemos verlo con el comando: <pre><code># Nos ddocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4a la informaci\u00f3n del almacenamiento utilizado por docker\ndocker system df -v\n</code></pre> Esto por ejemplo tambien ocurre cuando creamos contenedores con diferentes versiones de una misma imagen, muchas de sus capas, son compartidas.</p> <p>Cuando creamos un contenedor, usa el FS de la imagen en <code>solo lectura</code>. Por tanto, cuando instalamos o modificamos algo en un contenedor, esto se hace en una nueva <code>capa de lectura/escritura</code> que se genera al crearlo, para as\u00ed no modificar las capas de la imagen. De este modo, si creamos varios contenedores a partir de la misma imagen, todos ellos compartirar el mismo FS.</p> <p>Esto hace que al crear un contenedor, su tama\u00f1o sea m\u00ednimo Esto podemos verlo con el comando: <pre><code># La opdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4ci\u00f3n -s nos muestra el tama\u00f1o del contenedor\n# indicando el tama\u00f1o de la capa R/W del contenedor y\n# el tama\u00f1o (virtual) del FS de la imagen usada\ndocker ps -a -s\n</code></pre></p> <p>Cuando borramos un contenedor, esta capa R/W desaparece, se perder\u00edan los datos de ese contenedor.</p>"},{"location":"unidad4/ud4/#gestion-de-imagenes","title":"GESTI\u00d3N DE IM\u00c1GENES","text":"<ul> <li> <p>Buscar im\u00e1gnes en Docker Hub: <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4search nginx\n\n# Si queremos ver lso posibles filtros\ndocker searhc --help\n</code></pre></p> </li> <li> <p>Para borrar una imagen que ya no vayamos a usar: <pre><code># OJO! docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4La imagen no se podr\u00e1 borrar mientras exista algun conenedor creado a partir de ella\ndocker rmi hello-world\n</code></pre></p> </li> <li> <p>Ver la informaci\u00f3n detallada de una imagen, como su identificador, puertos que utiliza, arquitectura, SO, variables de entorno, el comando por defecto, las distintas capas... <pre><code>docker docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4inspect nginx:stable\n</code></pre></p> </li> </ul>"},{"location":"unidad4/ud4/#docker-hub","title":"DOCKER HUB","text":"<p>Enlace Docker Hub</p> <p>Su filosof\u00eda es bastante parecida a GitHub, ya que denominan a las im\u00e1genes como repositorios y usan practicamente los mismos comandos que este (pull, push, commit...)</p> <p>Existe contenido confiable marcado con 3 tipos de insignias, como <code>imagen oficial de docker</code> (las mantiene el equipo de docker), <code>proveedores verificados</code> (suelen ser fabricantes reconocidos) y <code>proyectos de c\u00f3digo libre esponsorizados</code>.</p> <p>Podemos entrar a un repositorio par ver toda su informaci\u00f3n, etiquetas, versiones, como utilizarlo... Hay imagenes de SO, de servicios (apache, maraidb...), de lenguajes de programaci\u00f3n o aplicaciones comerciales (Wordpress...)</p> <p>Es imporante tener en cuenta la arquitectura en la que estamos trabajando, ya que dependiendo de eso deberemos buscar una imagen u otra.</p>"},{"location":"unidad4/ud4/#almacenamiento-de-datos-en-docker","title":"ALMACENAMIENTO DE DATOS EN DOCKER","text":"<p>Para no perder la informaci\u00f3n generada por los contenedores una vez sean borrados (por defecto se guarda en la capa R/W del contenedor), existen formas de almacenarla en el equipo anfitri\u00f3n.</p> <p>Un VOLUMEN es un directorio creado y gestionados \u00fanicamente por Docker, que se va a montar en un directorio interno del contenedor. Es decir, cuando guardemos informaci\u00f3n en ese directorio montado, se estaremos escribiendo en el directorio de nuestro Host que corresponde a ese volumen. Es decir, esa informaci\u00f3n no se perder\u00eda al borrar el contenedor.</p> <p>El directorio del contenedor donde se montan es <code>/var/lib/docker/volumes/</code>.</p> <p>Los vol\u00famenes se pueden montar simultaneamente en diferentes contenedores (almacenamiento compartido). Es decir, lo que escribe un contenedor, puede ser leido m\u00e1s tarde por otro contenedor.</p> <p>Como la informaci\u00f3n persiste al borrar el contenedor, podemos usar esa informaci\u00f3n para que sea utilizada por otro contenedor que creemos en el futuro. Adem\u00e1s, gracias a esto son muy \u00fatiles para realizar copias de seguridad o migrar datos.</p> <pre><code># Dos pdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4osibles formas de asociar un Volumen a un contenedor:\n-v miweb:/usr/local/apache2/htdocs:ro\n\n# \u00f3\n--mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs,ro\n</code></pre> <p>Otra opci\u00f3n es BIND MOUNT, que es un directorio o fichero propiedad del usuario, que podemos montar en un directorio interno del contenedor.</p> <p>Se referencian por su ruta completa, aunque podemos crear un punto de montaje para m\u00e1s comodidad.</p> <p>En este caso, no se gestionan desde el cliente Docker. Y se puede cambiar su contenido desde el anfitri\u00f3n.</p> <p>Son \u00fatiles cuando queremos compartir archivos de configuraci\u00f3n o c\u00f3digo fuente en nuestro contenedor.</p> <pre><code># Dos pdocker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4osibles formas de asociar un Bind Mount a un contenedor:\n-v /opt/web:/usr/local/apache2/htdocs:ro\n\n# \u00f3\n--mount type=bind,src=/opt/web,dst=/usr/local/apache2/htdocs,ro\n</code></pre> <ul> <li>Ejercicio con Vol\u00famenes: Todos los subcomandos de acciones con Vol\u00famenes, estan bajo el bloque <code>docker volume</code>. Por ejemplo:</li> </ul> <pre><code># Para docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4crear un volumen:\ndocker volume create mivolumen\n\n# Para borrar un volumen:\ndocker volume rm mivolumen\n\n# Mostrar los volumenes creados:\ndocker volume ls\n\n# Mostrar informaci\u00f3n detallada de un volumen que hayamos creado:\ndocker volume inspect mivolumen\n</code></pre> <p>Para asociar un contenedor a un volumen que hayamos creado, un comando de ejemplo ser\u00eda el siguiente. Aunque igualmente, si indicamos un volumen que no se haya creado previamente, docker lo crear\u00e1 en este momento: <pre><code>docker run -d --name my-apache-app --mount type=volume,src=miweb,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n</code></pre> Podemos comprobar el acceso al servidor web usando el navegador web o desde la consola, usando el comando <code>curl</code>: <pre><code>curl http://localhost:8080\n</code></pre></p> <ul> <li>Ejercicios con Bind Mount:</li> </ul> <p>En este caso, no necesitamos crear vol\u00famenes, si no que vamos a crear un directorio en el sistema de archivos del Host, donde a\u00f1adiremos nuestro fichero <code>index.html</code>. Para ello, desde la consola del host:</p> <pre><code>mkdir web\ncd web\necho \"&lt;h1&gt;Hola Mundo&lt;/h1&gt;\" &gt; index.html\n</code></pre> <p>A continuaci\u00f3n, ya podemos montar ese directorio en un contenedor: <pre><code>docker run -d --name my-apache-app --mount type=bind,src=/home/usuario/web,dst=/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n\n# O si lo preferimos, ser\u00eda lo mismo que:\ndocker run -d --name my-apache-app -v /home/usuario/web:/usr/local/apache2/htdocs -p 8080:80 httpd:2.4\n</code></pre></p> <p>En este caso, con bind mount, puedo modificar mi fichero HTML desde el anfitri\u00f3n y al estar montado, esos cambios se ver\u00e1n directamente reflejados en mi servidor web.</p>"},{"location":"unidad4/ud4/#desplegar-el-servicio-nextcloud-en-un-contenedor-con-almacenamiento-persistente","title":"DESPLEGAR EL SERVICIO NEXTCLOUD EN UN CONTENEDOR CON ALMACENAMIENTO PERSISTENTE","text":"<p>Lo primero es ir a la p\u00e1gina de documentaci\u00f3n de la imagen de Nextcloud en Docker Hub.</p> <p>All\u00ed buscamos el apartado <code>Persistent data</code> para saber cual es el directorio que debo montar en un volumen para no perder los datos que nos interesan generados por esta aplicaci\u00f3n. En este caso ser\u00eda <code>/var/www/html</code>.</p> <p>Por lo tanto, si usamos volumenes el comando quedar\u00eda algo as\u00ed: <pre><code>docker run -d -p 8080:80 -v nextcloud:/var/www/html --name contenedor_nextcloud nextcloud:28.0.1\n</code></pre></p>"},{"location":"unidad4/ud4/#desplegar-el-servicio-mariadb-en-un-contenedor-con-almacenamiento-persistente","title":"DESPLEGAR EL SERVICIO MARIADB EN UN CONTENEDOR CON ALMACENAMIENTO PERSISTENTE","text":"<p>De nuevo, vamos a la p\u00e1gina de documentaci\u00f3n de la imagen que vamos a usar en Docker Hub.</p> <p>En el caso de MariaDB, la informaci\u00f3n sobre alamcenamiento persistente, aparece bajo el t\u00edtulo <code>Where to Store Data</code>. Ah\u00ed podemos leer que el directorio a montar es <code>/var/lib/mysql</code></p> <p>En este caso vamos a hacerlo con Bind Mount, y quedar\u00eda as\u00ed: <pre><code>docker run --name some-mariadb -v /opt/mariadb:/var/lib/mysql -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb:10.5\n</code></pre></p> <p>Si el directorio <code>/opt/mariadb</code> no existe en nuestro host, con la opci\u00f3n -v se crear\u00e1 en ese momento.</p>"},{"location":"unidad4/ud4/#otros-usos-del-almacenamiento-persistente","title":"OTROS USOS DEL ALMACENAMIENTO PERSISTENTE","text":"<p>Almacenamiento compartido entre distintos contenedores.</p> <p>Por ejemplo, tener un servidor web en un contenedor, cuyo <code>index.html</code> deba ser actualizarse autom\u00e1ticamente leyendo de un repositorio GitHub o similar. Podemos tener un segundo contenedor, que modifique el c\u00f3digo de ese HTML.</p> <p>Otro ejemplo ser\u00eda probar como funciona un mismo c\u00f3digo en diferentes versiones del lenguaje de programaci\u00f3n (vease el caso de PHP que hay isntrucciones que cambian su comportamiento entre la versi\u00f3n 5 y la 7, o entre la 7 y la 8).</p>"}]}